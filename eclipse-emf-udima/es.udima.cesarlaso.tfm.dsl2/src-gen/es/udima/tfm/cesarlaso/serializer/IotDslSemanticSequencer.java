/*
 * generated by Xtext 2.12.0
 */
package es.udima.tfm.cesarlaso.serializer;

import com.google.inject.Inject;
import es.udima.cesarlaso.tfm.communicationsevents.CommunicationseventsPackage;
import es.udima.cesarlaso.tfm.communicationsevents.NetworkConnected;
import es.udima.cesarlaso.tfm.communicationsevents.NetworkDisconnected;
import es.udima.cesarlaso.tfm.communicationsevents.ServerConnected;
import es.udima.cesarlaso.tfm.communicationsevents.ServerDisconnected;
import es.udima.cesarlaso.tfm.communicationsprograms.CommunicationsprogramsPackage;
import es.udima.cesarlaso.tfm.communicationsprograms.RemoteActuator;
import es.udima.cesarlaso.tfm.communicationsprograms.RemoteActuatorIdentifier;
import es.udima.cesarlaso.tfm.communicationsprograms.RemoteEvent;
import es.udima.cesarlaso.tfm.communicationsprograms.RemoteEventIdentifier;
import es.udima.cesarlaso.tfm.deploymentdevices.Beaglebone;
import es.udima.cesarlaso.tfm.deploymentdevices.DeploymentdevicesPackage;
import es.udima.cesarlaso.tfm.deploymentdevices.ESP8266;
import es.udima.cesarlaso.tfm.deploymentdevices.Raspberry;
import es.udima.cesarlaso.tfm.deploymentdevices.Simulator;
import es.udima.cesarlaso.tfm.deploymentdevices.WifiConfiguration;
import es.udima.cesarlaso.tfm.events.EventsPackage;
import es.udima.cesarlaso.tfm.events.SequentialActuators;
import es.udima.cesarlaso.tfm.gpios.AnalogInputPin;
import es.udima.cesarlaso.tfm.gpios.AnalogOutputPin;
import es.udima.cesarlaso.tfm.gpios.DigitalInputPin;
import es.udima.cesarlaso.tfm.gpios.DigitalOutputPin;
import es.udima.cesarlaso.tfm.gpios.GpiosPackage;
import es.udima.cesarlaso.tfm.gpiosactuators.BlinkOutput;
import es.udima.cesarlaso.tfm.gpiosactuators.BlinkTimerOutput;
import es.udima.cesarlaso.tfm.gpiosactuators.ButtonOutput;
import es.udima.cesarlaso.tfm.gpiosactuators.ChangeOutput;
import es.udima.cesarlaso.tfm.gpiosactuators.GpiosactuatorsPackage;
import es.udima.cesarlaso.tfm.gpiosactuators.PulseOutput;
import es.udima.cesarlaso.tfm.gpiosactuators.Pwm;
import es.udima.cesarlaso.tfm.gpiosactuators.TransformTo;
import es.udima.cesarlaso.tfm.gpiosevents.AnalogRead;
import es.udima.cesarlaso.tfm.gpiosevents.AnalogReadPerformOnHigh;
import es.udima.cesarlaso.tfm.gpiosevents.AnalogReadPerformOnLow;
import es.udima.cesarlaso.tfm.gpiosevents.ButtonInput;
import es.udima.cesarlaso.tfm.gpiosevents.ButtonInputAccumulator;
import es.udima.cesarlaso.tfm.gpiosevents.ButtonInputReleased;
import es.udima.cesarlaso.tfm.gpiosevents.GpioseventsPackage;
import es.udima.cesarlaso.tfm.gpiosevents.Interrupted;
import es.udima.cesarlaso.tfm.gpiosevents.PulseInput;
import es.udima.cesarlaso.tfm.iotproyects.IotProyect;
import es.udima.cesarlaso.tfm.iotproyects.IotproyectsPackage;
import es.udima.cesarlaso.tfm.operatingsystemactuators.BackgroundImage;
import es.udima.cesarlaso.tfm.operatingsystemactuators.Download;
import es.udima.cesarlaso.tfm.operatingsystemactuators.DrawImage;
import es.udima.cesarlaso.tfm.operatingsystemactuators.FilePath;
import es.udima.cesarlaso.tfm.operatingsystemactuators.OperatingsystemactuatorsPackage;
import es.udima.cesarlaso.tfm.operatingsystemactuators.PlaySound;
import es.udima.cesarlaso.tfm.operatingsystemactuators.PlayVideo;
import es.udima.cesarlaso.tfm.operatingsystemactuators.SystemCommand;
import es.udima.cesarlaso.tfm.programs.ChangeStateActuator;
import es.udima.cesarlaso.tfm.programs.Program;
import es.udima.cesarlaso.tfm.programs.ProgramState;
import es.udima.cesarlaso.tfm.programs.ProgramsPackage;
import es.udima.cesarlaso.tfm.servers.JavaServer;
import es.udima.cesarlaso.tfm.servers.ServersPackage;
import es.udima.cesarlaso.tfm.timers.Clock;
import es.udima.cesarlaso.tfm.timers.Cron;
import es.udima.cesarlaso.tfm.timers.Now;
import es.udima.cesarlaso.tfm.timers.Repeated;
import es.udima.cesarlaso.tfm.timers.Time;
import es.udima.cesarlaso.tfm.timers.TimeUnitValue;
import es.udima.cesarlaso.tfm.timers.TimerEvent;
import es.udima.cesarlaso.tfm.timers.TimersPackage;
import es.udima.tfm.cesarlaso.services.IotDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class IotDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private IotDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CommunicationseventsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CommunicationseventsPackage.NETWORK_CONNECTED:
				sequence_NetworkConnected(context, (NetworkConnected) semanticObject); 
				return; 
			case CommunicationseventsPackage.NETWORK_DISCONNECTED:
				sequence_NetworkDisconnected(context, (NetworkDisconnected) semanticObject); 
				return; 
			case CommunicationseventsPackage.SERVER_CONNECTED:
				sequence_ServerConnected(context, (ServerConnected) semanticObject); 
				return; 
			case CommunicationseventsPackage.SERVER_DISCONNECTED:
				sequence_ServerDisconnected(context, (ServerDisconnected) semanticObject); 
				return; 
			}
		else if (epackage == CommunicationsprogramsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CommunicationsprogramsPackage.REMOTE_ACTUATOR:
				sequence_RemoteActuator(context, (RemoteActuator) semanticObject); 
				return; 
			case CommunicationsprogramsPackage.REMOTE_ACTUATOR_IDENTIFIER:
				sequence_RemoteActuatorIdentifier(context, (RemoteActuatorIdentifier) semanticObject); 
				return; 
			case CommunicationsprogramsPackage.REMOTE_EVENT:
				sequence_RemoteEvent(context, (RemoteEvent) semanticObject); 
				return; 
			case CommunicationsprogramsPackage.REMOTE_EVENT_IDENTIFIER:
				sequence_RemoteEventIdentifier(context, (RemoteEventIdentifier) semanticObject); 
				return; 
			}
		else if (epackage == DeploymentdevicesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DeploymentdevicesPackage.BEAGLEBONE:
				sequence_Beaglebone(context, (Beaglebone) semanticObject); 
				return; 
			case DeploymentdevicesPackage.ESP8266:
				sequence_ESP8266(context, (ESP8266) semanticObject); 
				return; 
			case DeploymentdevicesPackage.RASPBERRY:
				sequence_Raspberry(context, (Raspberry) semanticObject); 
				return; 
			case DeploymentdevicesPackage.SIMULATOR:
				sequence_Simulator(context, (Simulator) semanticObject); 
				return; 
			case DeploymentdevicesPackage.WIFI_CONFIGURATION:
				sequence_WifiConfiguration(context, (WifiConfiguration) semanticObject); 
				return; 
			}
		else if (epackage == EventsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EventsPackage.SEQUENTIAL_ACTUATORS:
				sequence_SequentialActuators(context, (SequentialActuators) semanticObject); 
				return; 
			}
		else if (epackage == GpiosPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GpiosPackage.ANALOG_INPUT_PIN:
				sequence_AnalogInputPin(context, (AnalogInputPin) semanticObject); 
				return; 
			case GpiosPackage.ANALOG_OUTPUT_PIN:
				sequence_AnalogOutputPin(context, (AnalogOutputPin) semanticObject); 
				return; 
			case GpiosPackage.DIGITAL_INPUT_PIN:
				sequence_DigitalInputPin(context, (DigitalInputPin) semanticObject); 
				return; 
			case GpiosPackage.DIGITAL_OUTPUT_PIN:
				sequence_DigitalOutputPin(context, (DigitalOutputPin) semanticObject); 
				return; 
			}
		else if (epackage == GpiosactuatorsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GpiosactuatorsPackage.BLINK_OUTPUT:
				sequence_BlinkOutput(context, (BlinkOutput) semanticObject); 
				return; 
			case GpiosactuatorsPackage.BLINK_TIMER_OUTPUT:
				sequence_BlinkTimerOutput(context, (BlinkTimerOutput) semanticObject); 
				return; 
			case GpiosactuatorsPackage.BUTTON_OUTPUT:
				sequence_ButtonOutput(context, (ButtonOutput) semanticObject); 
				return; 
			case GpiosactuatorsPackage.CHANGE_OUTPUT:
				sequence_ChangeOutput(context, (ChangeOutput) semanticObject); 
				return; 
			case GpiosactuatorsPackage.PULSE_OUTPUT:
				sequence_PulseOutput(context, (PulseOutput) semanticObject); 
				return; 
			case GpiosactuatorsPackage.PWM:
				sequence_Pwm(context, (Pwm) semanticObject); 
				return; 
			case GpiosactuatorsPackage.TRANSFORM_TO:
				sequence_TransformTo(context, (TransformTo) semanticObject); 
				return; 
			}
		else if (epackage == GpioseventsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GpioseventsPackage.ANALOG_READ:
				sequence_GpioAnalogRead(context, (AnalogRead) semanticObject); 
				return; 
			case GpioseventsPackage.ANALOG_READ_PERFORM_ON_HIGH:
				sequence_GpioAnalogReadPerformOnHigh(context, (AnalogReadPerformOnHigh) semanticObject); 
				return; 
			case GpioseventsPackage.ANALOG_READ_PERFORM_ON_LOW:
				sequence_GpioAnalogReadPerformOnLow(context, (AnalogReadPerformOnLow) semanticObject); 
				return; 
			case GpioseventsPackage.BUTTON_INPUT:
				sequence_GpioButtonInput(context, (ButtonInput) semanticObject); 
				return; 
			case GpioseventsPackage.BUTTON_INPUT_ACCUMULATOR:
				sequence_GpioButtonInputAccumulator(context, (ButtonInputAccumulator) semanticObject); 
				return; 
			case GpioseventsPackage.BUTTON_INPUT_RELEASED:
				sequence_GpioButtonReleased(context, (ButtonInputReleased) semanticObject); 
				return; 
			case GpioseventsPackage.INTERRUPTED:
				sequence_GpioInterrupted(context, (Interrupted) semanticObject); 
				return; 
			case GpioseventsPackage.PULSE_INPUT:
				sequence_GpioPulseInput(context, (PulseInput) semanticObject); 
				return; 
			}
		else if (epackage == IotproyectsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case IotproyectsPackage.IOT_PROYECT:
				sequence_IotProyect(context, (IotProyect) semanticObject); 
				return; 
			}
		else if (epackage == OperatingsystemactuatorsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OperatingsystemactuatorsPackage.BACKGROUND_IMAGE:
				sequence_BackgroundImage(context, (BackgroundImage) semanticObject); 
				return; 
			case OperatingsystemactuatorsPackage.DOWNLOAD:
				sequence_Download(context, (Download) semanticObject); 
				return; 
			case OperatingsystemactuatorsPackage.DRAW_IMAGE:
				sequence_DrawImage(context, (DrawImage) semanticObject); 
				return; 
			case OperatingsystemactuatorsPackage.FILE_PATH:
				sequence_FilePath(context, (FilePath) semanticObject); 
				return; 
			case OperatingsystemactuatorsPackage.PLAY_SOUND:
				sequence_PlaySound(context, (PlaySound) semanticObject); 
				return; 
			case OperatingsystemactuatorsPackage.PLAY_VIDEO:
				sequence_PlayVideo(context, (PlayVideo) semanticObject); 
				return; 
			case OperatingsystemactuatorsPackage.SYSTEM_COMMAND:
				sequence_SystemCommand(context, (SystemCommand) semanticObject); 
				return; 
			}
		else if (epackage == ProgramsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ProgramsPackage.CHANGE_STATE_ACTUATOR:
				sequence_ChangeStateActuator(context, (ChangeStateActuator) semanticObject); 
				return; 
			case ProgramsPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case ProgramsPackage.PROGRAM_STATE:
				sequence_ProgramState(context, (ProgramState) semanticObject); 
				return; 
			}
		else if (epackage == ServersPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ServersPackage.JAVA_SERVER:
				sequence_JavaServer(context, (JavaServer) semanticObject); 
				return; 
			}
		else if (epackage == TimersPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TimersPackage.CLOCK:
				sequence_Clock(context, (Clock) semanticObject); 
				return; 
			case TimersPackage.CRON:
				sequence_Cron(context, (Cron) semanticObject); 
				return; 
			case TimersPackage.NOW:
				sequence_Now(context, (Now) semanticObject); 
				return; 
			case TimersPackage.REPEATED:
				sequence_Repeated(context, (Repeated) semanticObject); 
				return; 
			case TimersPackage.TIME:
				sequence_Time(context, (Time) semanticObject); 
				return; 
			case TimersPackage.TIME_UNIT_VALUE:
				sequence_TimeUnitValue(context, (TimeUnitValue) semanticObject); 
				return; 
			case TimersPackage.TIMER_EVENT:
				sequence_TimerEvent(context, (TimerEvent) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Pin returns AnalogInputPin
	 *     AnalogInputPin returns AnalogInputPin
	 *
	 * Constraint:
	 *     (name=EString number=EInt)
	 */
	protected void sequence_AnalogInputPin(ISerializationContext context, AnalogInputPin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpiosPackage.Literals.PIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosPackage.Literals.PIN__NAME));
			if (transientValues.isValueTransient(semanticObject, GpiosPackage.Literals.PIN__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosPackage.Literals.PIN__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnalogInputPinAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAnalogInputPinAccess().getNumberEIntParserRuleCall_3_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pin returns AnalogOutputPin
	 *     AnalogOutputPin returns AnalogOutputPin
	 *
	 * Constraint:
	 *     (name=EString number=EInt)
	 */
	protected void sequence_AnalogOutputPin(ISerializationContext context, AnalogOutputPin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpiosPackage.Literals.PIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosPackage.Literals.PIN__NAME));
			if (transientValues.isValueTransient(semanticObject, GpiosPackage.Literals.PIN__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosPackage.Literals.PIN__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnalogOutputPinAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAnalogOutputPinAccess().getNumberEIntParserRuleCall_3_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns BackgroundImage
	 *     BackgroundImage returns BackgroundImage
	 *
	 * Constraint:
	 *     (filePath=[FilePath|EString] resizeType=ResizeType)
	 */
	protected void sequence_BackgroundImage(ISerializationContext context, BackgroundImage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.BACKGROUND_IMAGE__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.BACKGROUND_IMAGE__FILE_PATH));
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.BACKGROUND_IMAGE__RESIZE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.BACKGROUND_IMAGE__RESIZE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBackgroundImageAccess().getFilePathFilePathEStringParserRuleCall_1_0_1(), semanticObject.eGet(OperatingsystemactuatorsPackage.Literals.BACKGROUND_IMAGE__FILE_PATH, false));
		feeder.accept(grammarAccess.getBackgroundImageAccess().getResizeTypeResizeTypeEnumRuleCall_2_0(), semanticObject.getResizeType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Device returns Beaglebone
	 *     Beaglebone returns Beaglebone
	 *
	 * Constraint:
	 *     wifiConfiguration=WifiConfiguration?
	 */
	protected void sequence_Beaglebone(ISerializationContext context, Beaglebone semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns BlinkOutput
	 *     BlinkOutput returns BlinkOutput
	 *
	 * Constraint:
	 *     (pin=[DigitalOutputPin|EString] interval=TimeUnitValue)
	 */
	protected void sequence_BlinkOutput(ISerializationContext context, BlinkOutput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN));
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.BLINK_OUTPUT__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.BLINK_OUTPUT__INTERVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBlinkOutputAccess().getPinDigitalOutputPinEStringParserRuleCall_1_0_1(), semanticObject.eGet(GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN, false));
		feeder.accept(grammarAccess.getBlinkOutputAccess().getIntervalTimeUnitValueParserRuleCall_3_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns BlinkTimerOutput
	 *     BlinkTimerOutput returns BlinkTimerOutput
	 *
	 * Constraint:
	 *     (pin=[DigitalOutputPin|EString] duration=TimeUnitValue interval=TimeUnitValue)
	 */
	protected void sequence_BlinkTimerOutput(ISerializationContext context, BlinkTimerOutput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN));
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.GPIO_TIMER_ACTUATOR__DURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.GPIO_TIMER_ACTUATOR__DURATION));
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.BLINK_OUTPUT__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.BLINK_OUTPUT__INTERVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBlinkTimerOutputAccess().getPinDigitalOutputPinEStringParserRuleCall_1_0_1(), semanticObject.eGet(GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN, false));
		feeder.accept(grammarAccess.getBlinkTimerOutputAccess().getDurationTimeUnitValueParserRuleCall_4_0(), semanticObject.getDuration());
		feeder.accept(grammarAccess.getBlinkTimerOutputAccess().getIntervalTimeUnitValueParserRuleCall_6_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns ButtonOutput
	 *     ButtonOutput returns ButtonOutput
	 *
	 * Constraint:
	 *     (pin=[DigitalOutputPin|EString] duration=TimeUnitValue)
	 */
	protected void sequence_ButtonOutput(ISerializationContext context, ButtonOutput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN));
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.GPIO_TIMER_ACTUATOR__DURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.GPIO_TIMER_ACTUATOR__DURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getButtonOutputAccess().getPinDigitalOutputPinEStringParserRuleCall_1_0_1(), semanticObject.eGet(GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN, false));
		feeder.accept(grammarAccess.getButtonOutputAccess().getDurationTimeUnitValueParserRuleCall_3_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns ChangeOutput
	 *     ChangeOutput returns ChangeOutput
	 *
	 * Constraint:
	 *     (pin=[DigitalOutputPin|EString] status=DigitalPinStatus)
	 */
	protected void sequence_ChangeOutput(ISerializationContext context, ChangeOutput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN));
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.CHANGE_OUTPUT__STATUS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.CHANGE_OUTPUT__STATUS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChangeOutputAccess().getPinDigitalOutputPinEStringParserRuleCall_1_0_1(), semanticObject.eGet(GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN, false));
		feeder.accept(grammarAccess.getChangeOutputAccess().getStatusDigitalPinStatusEnumRuleCall_2_0(), semanticObject.getStatus());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns ChangeStateActuator
	 *     ChangeStateActuator returns ChangeStateActuator
	 *
	 * Constraint:
	 *     state=[ProgramState|EString]
	 */
	protected void sequence_ChangeStateActuator(ISerializationContext context, ChangeStateActuator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramsPackage.Literals.CHANGE_STATE_ACTUATOR__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramsPackage.Literals.CHANGE_STATE_ACTUATOR__STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChangeStateActuatorAccess().getStateProgramStateEStringParserRuleCall_1_0_1(), semanticObject.eGet(ProgramsPackage.Literals.CHANGE_STATE_ACTUATOR__STATE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Timer returns Clock
	 *     Clock returns Clock
	 *
	 * Constraint:
	 *     value=Time
	 */
	protected void sequence_Clock(ISerializationContext context, Clock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TimersPackage.Literals.CLOCK__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TimersPackage.Literals.CLOCK__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClockAccess().getValueTimeParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Timer returns Cron
	 *     Cron returns Cron
	 *
	 * Constraint:
	 *     value=EString
	 */
	protected void sequence_Cron(ISerializationContext context, Cron semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TimersPackage.Literals.CRON__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TimersPackage.Literals.CRON__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCronAccess().getValueEStringParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pin returns DigitalInputPin
	 *     DigitalInputPin returns DigitalInputPin
	 *
	 * Constraint:
	 *     (name=EString number=EInt)
	 */
	protected void sequence_DigitalInputPin(ISerializationContext context, DigitalInputPin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpiosPackage.Literals.PIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosPackage.Literals.PIN__NAME));
			if (transientValues.isValueTransient(semanticObject, GpiosPackage.Literals.PIN__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosPackage.Literals.PIN__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDigitalInputPinAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDigitalInputPinAccess().getNumberEIntParserRuleCall_3_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pin returns DigitalOutputPin
	 *     DigitalOutputPin returns DigitalOutputPin
	 *
	 * Constraint:
	 *     (name=EString number=EInt)
	 */
	protected void sequence_DigitalOutputPin(ISerializationContext context, DigitalOutputPin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpiosPackage.Literals.PIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosPackage.Literals.PIN__NAME));
			if (transientValues.isValueTransient(semanticObject, GpiosPackage.Literals.PIN__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosPackage.Literals.PIN__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDigitalOutputPinAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDigitalOutputPinAccess().getNumberEIntParserRuleCall_3_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns Download
	 *     Download returns Download
	 *
	 * Constraint:
	 *     (url=EString filePath=[FilePath|EString])
	 */
	protected void sequence_Download(ISerializationContext context, Download semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.DOWNLOAD__URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.DOWNLOAD__URL));
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.DOWNLOAD__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.DOWNLOAD__FILE_PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDownloadAccess().getUrlEStringParserRuleCall_1_0(), semanticObject.getUrl());
		feeder.accept(grammarAccess.getDownloadAccess().getFilePathFilePathEStringParserRuleCall_3_0_1(), semanticObject.eGet(OperatingsystemactuatorsPackage.Literals.DOWNLOAD__FILE_PATH, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns DrawImage
	 *     DrawImage returns DrawImage
	 *
	 * Constraint:
	 *     (
	 *         filePath=[FilePath|EString] 
	 *         positionX=EInt 
	 *         positionY=EInt 
	 *         positionZ=EInt 
	 *         color=ELong 
	 *         resizeType=ResizeType
	 *     )
	 */
	protected void sequence_DrawImage(ISerializationContext context, DrawImage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__FILE_PATH));
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__POSITION_X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__POSITION_X));
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__POSITION_Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__POSITION_Y));
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__POSITION_Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__POSITION_Z));
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__COLOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__COLOR));
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__RESIZE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__RESIZE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDrawImageAccess().getFilePathFilePathEStringParserRuleCall_1_0_1(), semanticObject.eGet(OperatingsystemactuatorsPackage.Literals.SCREEN__FILE_PATH, false));
		feeder.accept(grammarAccess.getDrawImageAccess().getPositionXEIntParserRuleCall_4_0(), semanticObject.getPositionX());
		feeder.accept(grammarAccess.getDrawImageAccess().getPositionYEIntParserRuleCall_6_0(), semanticObject.getPositionY());
		feeder.accept(grammarAccess.getDrawImageAccess().getPositionZEIntParserRuleCall_8_0(), semanticObject.getPositionZ());
		feeder.accept(grammarAccess.getDrawImageAccess().getColorELongParserRuleCall_10_0(), semanticObject.getColor());
		feeder.accept(grammarAccess.getDrawImageAccess().getResizeTypeResizeTypeEnumRuleCall_12_0(), semanticObject.getResizeType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Device returns ESP8266
	 *     ESP8266 returns ESP8266
	 *
	 * Constraint:
	 *     wifiConfiguration=WifiConfiguration?
	 */
	protected void sequence_ESP8266(ISerializationContext context, ESP8266 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FilePath returns FilePath
	 *
	 * Constraint:
	 *     (name=EString filePath=EString)
	 */
	protected void sequence_FilePath(ISerializationContext context, FilePath semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.FILE_PATH__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.FILE_PATH__NAME));
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.FILE_PATH__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.FILE_PATH__FILE_PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFilePathAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFilePathAccess().getFilePathEStringParserRuleCall_3_0(), semanticObject.getFilePath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns AnalogReadPerformOnHigh
	 *     GpioAnalogReadPerformOnHigh returns AnalogReadPerformOnHigh
	 *
	 * Constraint:
	 *     (pin=[AnalogInputPin|EString] pollIntervalLoops=EInt value=EInt actuators+=Actuator actuators+=Actuator*)
	 */
	protected void sequence_GpioAnalogReadPerformOnHigh(ISerializationContext context, AnalogReadPerformOnHigh semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns AnalogReadPerformOnLow
	 *     GpioAnalogReadPerformOnLow returns AnalogReadPerformOnLow
	 *
	 * Constraint:
	 *     (pin=[AnalogInputPin|EString] pollIntervalLoops=EInt value=EInt actuators+=Actuator actuators+=Actuator*)
	 */
	protected void sequence_GpioAnalogReadPerformOnLow(ISerializationContext context, AnalogReadPerformOnLow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns AnalogRead
	 *     GpioAnalogRead returns AnalogRead
	 *
	 * Constraint:
	 *     (pin=[AnalogInputPin|EString] pollIntervalLoops=EInt actuators+=Actuator actuators+=Actuator*)
	 */
	protected void sequence_GpioAnalogRead(ISerializationContext context, AnalogRead semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns ButtonInputAccumulator
	 *     GpioButtonInputAccumulator returns ButtonInputAccumulator
	 *
	 * Constraint:
	 *     (
	 *         pin=[DigitalInputPin|EString] 
	 *         mode=PinResistor 
	 *         minDuration=EInt 
	 *         count=EInt 
	 *         actuators+=Actuator 
	 *         actuators+=Actuator*
	 *     )
	 */
	protected void sequence_GpioButtonInputAccumulator(ISerializationContext context, ButtonInputAccumulator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns ButtonInput
	 *     GpioButtonInput returns ButtonInput
	 *
	 * Constraint:
	 *     (pin=[DigitalInputPin|EString] mode=PinResistor minDuration=EInt actuators+=Actuator actuators+=Actuator*)
	 */
	protected void sequence_GpioButtonInput(ISerializationContext context, ButtonInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns ButtonInputReleased
	 *     GpioButtonReleased returns ButtonInputReleased
	 *
	 * Constraint:
	 *     (pin=[DigitalInputPin|EString] mode=PinResistor actuators+=Actuator actuators+=Actuator*)
	 */
	protected void sequence_GpioButtonReleased(ISerializationContext context, ButtonInputReleased semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Interrupted
	 *     GpioInterrupted returns Interrupted
	 *
	 * Constraint:
	 *     (pin=[DigitalInputPin|EString] mode=GpioInterruptMode actuators+=Actuator actuators+=Actuator*)
	 */
	protected void sequence_GpioInterrupted(ISerializationContext context, Interrupted semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns PulseInput
	 *     GpioPulseInput returns PulseInput
	 *
	 * Constraint:
	 *     (
	 *         pin=[DigitalInputPin|EString] 
	 *         mode=PinResistor 
	 *         count=EInt 
	 *         width=EInt 
	 *         spaceWidth=EInt 
	 *         actuators+=Actuator 
	 *         actuators+=Actuator*
	 *     )
	 */
	protected void sequence_GpioPulseInput(ISerializationContext context, PulseInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IotProyect returns IotProyect
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         productCode=EInt 
	 *         version=EInt 
	 *         deploymentDevice+=Device 
	 *         deploymentDevice+=Device* 
	 *         server+=Server 
	 *         server+=Server* 
	 *         program=Program
	 *     )
	 */
	protected void sequence_IotProyect(ISerializationContext context, IotProyect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Server returns JavaServer
	 *     JavaServer returns JavaServer
	 *
	 * Constraint:
	 *     (networkInterfaceAddress=EString networkInterfacePort=EInt)
	 */
	protected void sequence_JavaServer(ISerializationContext context, JavaServer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ServersPackage.Literals.JAVA_SERVER__NETWORK_INTERFACE_ADDRESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ServersPackage.Literals.JAVA_SERVER__NETWORK_INTERFACE_ADDRESS));
			if (transientValues.isValueTransient(semanticObject, ServersPackage.Literals.JAVA_SERVER__NETWORK_INTERFACE_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ServersPackage.Literals.JAVA_SERVER__NETWORK_INTERFACE_PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJavaServerAccess().getNetworkInterfaceAddressEStringParserRuleCall_3_0(), semanticObject.getNetworkInterfaceAddress());
		feeder.accept(grammarAccess.getJavaServerAccess().getNetworkInterfacePortEIntParserRuleCall_5_0(), semanticObject.getNetworkInterfacePort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns NetworkConnected
	 *     NetworkConnected returns NetworkConnected
	 *
	 * Constraint:
	 *     (actuators+=Actuator actuators+=Actuator*)
	 */
	protected void sequence_NetworkConnected(ISerializationContext context, NetworkConnected semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns NetworkDisconnected
	 *     NetworkDisconnected returns NetworkDisconnected
	 *
	 * Constraint:
	 *     (actuators+=Actuator actuators+=Actuator*)
	 */
	protected void sequence_NetworkDisconnected(ISerializationContext context, NetworkDisconnected semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Timer returns Now
	 *     Now returns Now
	 *
	 * Constraint:
	 *     {Now}
	 */
	protected void sequence_Now(ISerializationContext context, Now semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns PlaySound
	 *     PlaySound returns PlaySound
	 *
	 * Constraint:
	 *     (volume=EInt? filePath=[FilePath|EString])
	 */
	protected void sequence_PlaySound(ISerializationContext context, PlaySound semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns PlayVideo
	 *     PlayVideo returns PlayVideo
	 *
	 * Constraint:
	 *     (
	 *         filePath=[FilePath|EString] 
	 *         positionX=EInt 
	 *         positionY=EInt 
	 *         positionZ=EInt 
	 *         color=ELong 
	 *         resizeType=ResizeType
	 *     )
	 */
	protected void sequence_PlayVideo(ISerializationContext context, PlayVideo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__FILE_PATH));
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__POSITION_X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__POSITION_X));
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__POSITION_Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__POSITION_Y));
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__POSITION_Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__POSITION_Z));
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__COLOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__COLOR));
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__RESIZE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.SCREEN__RESIZE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlayVideoAccess().getFilePathFilePathEStringParserRuleCall_1_0_1(), semanticObject.eGet(OperatingsystemactuatorsPackage.Literals.SCREEN__FILE_PATH, false));
		feeder.accept(grammarAccess.getPlayVideoAccess().getPositionXEIntParserRuleCall_4_0(), semanticObject.getPositionX());
		feeder.accept(grammarAccess.getPlayVideoAccess().getPositionYEIntParserRuleCall_6_0(), semanticObject.getPositionY());
		feeder.accept(grammarAccess.getPlayVideoAccess().getPositionZEIntParserRuleCall_8_0(), semanticObject.getPositionZ());
		feeder.accept(grammarAccess.getPlayVideoAccess().getColorELongParserRuleCall_10_0(), semanticObject.getColor());
		feeder.accept(grammarAccess.getPlayVideoAccess().getResizeTypeResizeTypeEnumRuleCall_12_0(), semanticObject.getResizeType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProgramState returns ProgramState
	 *
	 * Constraint:
	 *     (name=EString events+=Event events+=Event*)
	 */
	protected void sequence_ProgramState(ISerializationContext context, ProgramState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (
	 *         (gpioAliases+=Pin gpioAliases+=Pin*)? 
	 *         (remoteIdentifiers+=RemoteIdentifier remoteIdentifiers+=RemoteIdentifier*)? 
	 *         (files+=FilePath files+=FilePath*)? 
	 *         state=[ProgramState|EString] 
	 *         states+=ProgramState 
	 *         states+=ProgramState*
	 *     )
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns PulseOutput
	 *     PulseOutput returns PulseOutput
	 *
	 * Constraint:
	 *     (pin=[DigitalOutputPin|EString] count=EInt width=EInt spaceWidth=EInt)
	 */
	protected void sequence_PulseOutput(ISerializationContext context, PulseOutput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN));
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.PULSE_OUTPUT__COUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.PULSE_OUTPUT__COUNT));
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.PULSE_OUTPUT__WIDTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.PULSE_OUTPUT__WIDTH));
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.PULSE_OUTPUT__SPACE_WIDTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.PULSE_OUTPUT__SPACE_WIDTH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPulseOutputAccess().getPinDigitalOutputPinEStringParserRuleCall_1_0_1(), semanticObject.eGet(GpiosactuatorsPackage.Literals.DIGITAL_ACTUATOR__PIN, false));
		feeder.accept(grammarAccess.getPulseOutputAccess().getCountEIntParserRuleCall_4_0(), semanticObject.getCount());
		feeder.accept(grammarAccess.getPulseOutputAccess().getWidthEIntParserRuleCall_6_0(), semanticObject.getWidth());
		feeder.accept(grammarAccess.getPulseOutputAccess().getSpaceWidthEIntParserRuleCall_9_0(), semanticObject.getSpaceWidth());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns Pwm
	 *     Pwm returns Pwm
	 *
	 * Constraint:
	 *     (pin=[AnalogOutputPin|EString] value=EInt)
	 */
	protected void sequence_Pwm(ISerializationContext context, Pwm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.ANALOG_ACTUATOR__PIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.ANALOG_ACTUATOR__PIN));
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.PWM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.PWM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPwmAccess().getPinAnalogOutputPinEStringParserRuleCall_1_0_1(), semanticObject.eGet(GpiosactuatorsPackage.Literals.ANALOG_ACTUATOR__PIN, false));
		feeder.accept(grammarAccess.getPwmAccess().getValueEIntParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Device returns Raspberry
	 *     Raspberry returns Raspberry
	 *
	 * Constraint:
	 *     wifiConfiguration=WifiConfiguration?
	 */
	protected void sequence_Raspberry(ISerializationContext context, Raspberry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoteIdentifier returns RemoteActuatorIdentifier
	 *     RemoteActuatorIdentifier returns RemoteActuatorIdentifier
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_RemoteActuatorIdentifier(ISerializationContext context, RemoteActuatorIdentifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CommunicationsprogramsPackage.Literals.REMOTE_IDENTIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommunicationsprogramsPackage.Literals.REMOTE_IDENTIFIER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoteActuatorIdentifierAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns RemoteActuator
	 *     RemoteActuator returns RemoteActuator
	 *
	 * Constraint:
	 *     identifier=[RemoteActuatorIdentifier|EString]
	 */
	protected void sequence_RemoteActuator(ISerializationContext context, RemoteActuator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CommunicationsprogramsPackage.Literals.REMOTE_ACTUATOR__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommunicationsprogramsPackage.Literals.REMOTE_ACTUATOR__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoteActuatorAccess().getIdentifierRemoteActuatorIdentifierEStringParserRuleCall_1_0_1(), semanticObject.eGet(CommunicationsprogramsPackage.Literals.REMOTE_ACTUATOR__IDENTIFIER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RemoteIdentifier returns RemoteEventIdentifier
	 *     RemoteEventIdentifier returns RemoteEventIdentifier
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_RemoteEventIdentifier(ISerializationContext context, RemoteEventIdentifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CommunicationsprogramsPackage.Literals.REMOTE_IDENTIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommunicationsprogramsPackage.Literals.REMOTE_IDENTIFIER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoteEventIdentifierAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns RemoteEvent
	 *     RemoteEvent returns RemoteEvent
	 *
	 * Constraint:
	 *     (identifier=[RemoteEventIdentifier|EString] actuators+=Actuator actuators+=Actuator*)
	 */
	protected void sequence_RemoteEvent(ISerializationContext context, RemoteEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Timer returns Repeated
	 *     Repeated returns Repeated
	 *
	 * Constraint:
	 *     value=TimeUnitValue
	 */
	protected void sequence_Repeated(ISerializationContext context, Repeated semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TimersPackage.Literals.REPEATED__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TimersPackage.Literals.REPEATED__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeatedAccess().getValueTimeUnitValueParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns SequentialActuators
	 *     SequentialActuators returns SequentialActuators
	 *
	 * Constraint:
	 *     (actuators+=Actuator actuators+=Actuator*)
	 */
	protected void sequence_SequentialActuators(ISerializationContext context, SequentialActuators semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns ServerConnected
	 *     ServerConnected returns ServerConnected
	 *
	 * Constraint:
	 *     (actuators+=Actuator actuators+=Actuator*)
	 */
	protected void sequence_ServerConnected(ISerializationContext context, ServerConnected semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns ServerDisconnected
	 *     ServerDisconnected returns ServerDisconnected
	 *
	 * Constraint:
	 *     (actuators+=Actuator actuators+=Actuator*)
	 */
	protected void sequence_ServerDisconnected(ISerializationContext context, ServerDisconnected semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Device returns Simulator
	 *     Simulator returns Simulator
	 *
	 * Constraint:
	 *     {Simulator}
	 */
	protected void sequence_Simulator(ISerializationContext context, Simulator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns SystemCommand
	 *     SystemCommand returns SystemCommand
	 *
	 * Constraint:
	 *     filePath=[FilePath|EString]
	 */
	protected void sequence_SystemCommand(ISerializationContext context, SystemCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OperatingsystemactuatorsPackage.Literals.SYSTEM_COMMAND__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OperatingsystemactuatorsPackage.Literals.SYSTEM_COMMAND__FILE_PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSystemCommandAccess().getFilePathFilePathEStringParserRuleCall_1_0_1(), semanticObject.eGet(OperatingsystemactuatorsPackage.Literals.SYSTEM_COMMAND__FILE_PATH, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TimeUnitValue returns TimeUnitValue
	 *
	 * Constraint:
	 *     (value=EInt unit=TimeUnitType)
	 */
	protected void sequence_TimeUnitValue(ISerializationContext context, TimeUnitValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TimersPackage.Literals.TIME_UNIT_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TimersPackage.Literals.TIME_UNIT_VALUE__VALUE));
			if (transientValues.isValueTransient(semanticObject, TimersPackage.Literals.TIME_UNIT_VALUE__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TimersPackage.Literals.TIME_UNIT_VALUE__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeUnitValueAccess().getValueEIntParserRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getTimeUnitValueAccess().getUnitTimeUnitTypeEnumRuleCall_1_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Time returns Time
	 *
	 * Constraint:
	 *     (hour=EInt minute=EInt second=EInt)
	 */
	protected void sequence_Time(ISerializationContext context, Time semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TimersPackage.Literals.TIME__HOUR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TimersPackage.Literals.TIME__HOUR));
			if (transientValues.isValueTransient(semanticObject, TimersPackage.Literals.TIME__MINUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TimersPackage.Literals.TIME__MINUTE));
			if (transientValues.isValueTransient(semanticObject, TimersPackage.Literals.TIME__SECOND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TimersPackage.Literals.TIME__SECOND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeAccess().getHourEIntParserRuleCall_0_0(), semanticObject.getHour());
		feeder.accept(grammarAccess.getTimeAccess().getMinuteEIntParserRuleCall_2_0(), semanticObject.getMinute());
		feeder.accept(grammarAccess.getTimeAccess().getSecondEIntParserRuleCall_4_0(), semanticObject.getSecond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns TimerEvent
	 *     TimerEvent returns TimerEvent
	 *
	 * Constraint:
	 *     (timer=Timer actuators+=Actuator actuators+=Actuator*)
	 */
	protected void sequence_TimerEvent(ISerializationContext context, TimerEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Actuator returns TransformTo
	 *     TransformTo returns TransformTo
	 *
	 * Constraint:
	 *     (pin=[AnalogOutputPin|EString] value=EInt duration=TimeUnitValue)
	 */
	protected void sequence_TransformTo(ISerializationContext context, TransformTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.ANALOG_ACTUATOR__PIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.ANALOG_ACTUATOR__PIN));
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.TRANSFORM_TO__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.TRANSFORM_TO__VALUE));
			if (transientValues.isValueTransient(semanticObject, GpiosactuatorsPackage.Literals.GPIO_TIMER_ACTUATOR__DURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpiosactuatorsPackage.Literals.GPIO_TIMER_ACTUATOR__DURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTransformToAccess().getPinAnalogOutputPinEStringParserRuleCall_1_0_1(), semanticObject.eGet(GpiosactuatorsPackage.Literals.ANALOG_ACTUATOR__PIN, false));
		feeder.accept(grammarAccess.getTransformToAccess().getValueEIntParserRuleCall_4_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getTransformToAccess().getDurationTimeUnitValueParserRuleCall_6_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WifiConfiguration returns WifiConfiguration
	 *
	 * Constraint:
	 *     (ssid=EString password=EString)
	 */
	protected void sequence_WifiConfiguration(ISerializationContext context, WifiConfiguration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeploymentdevicesPackage.Literals.WIFI_CONFIGURATION__SSID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeploymentdevicesPackage.Literals.WIFI_CONFIGURATION__SSID));
			if (transientValues.isValueTransient(semanticObject, DeploymentdevicesPackage.Literals.WIFI_CONFIGURATION__PASSWORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeploymentdevicesPackage.Literals.WIFI_CONFIGURATION__PASSWORD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWifiConfigurationAccess().getSsidEStringParserRuleCall_1_0(), semanticObject.getSsid());
		feeder.accept(grammarAccess.getWifiConfigurationAccess().getPasswordEStringParserRuleCall_3_0(), semanticObject.getPassword());
		feeder.finish();
	}
	
	
}
